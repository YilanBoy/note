# 所有權 (Ownership)

所有權為 Rust 最獨特的功能，這讓 Rust 不需要垃圾回收就可以保障記憶體安全

一些語言具有垃圾回收機制 (Garbage Collection)，會在程式執行時不停的尋找不再使用的記憶體，將這些記憶體釋放並歸還給作業系統。另外一些語言需要由開發者自行分配並釋放記憶體

Rust 選擇第三種方式，通過所有權管理記憶體

## Stack 與 Heap

### Stack

Stack 與 Heap 都是程式執行時可供使用的記憶體，但是它們結構不同

**Stack 以放入的順序儲存，並以相反的順序取出值**，這類似疊盤子與取出盤子的方式，新放置的盤子只能疊在原放置盤子的上方，拿走盤子時也只能取下最上方的盤子

這種取資料的方式為後進後出 (last in, first out)，增加資料叫做 pushing onto the stack，移出資料叫做 popping off the stack

Stack 的操作十分迅速，因為資料存取的位置總在 Stack 頂部，因此不需要尋找位置存放或是讀取資料

另一個讓 Stack 操作快速的原因是 Stack 中所有資料都**必須占用已知且固定的大小**

### Heap

在編譯大小未知或是大小可能變化的資料，應該改為儲存在 Heap 上

Heap 是缺乏組織的，當要向 Heap 放入資料時，需要請求一定大小的空間，作業系統會在 Heap 的某處找到一塊足夠大的空間來存放資料，並將其標記為已使用，最後返回一個該位置位址的指標 (pointer)，這個過程稱為在 Heap 上分配記憶體 (allocating on the heap)，有時候簡稱為分配 (allocating)

注意在 Stack 上放置資料並不被認為是分配，因為指標的大小事已知且固定的

訪問 Heap 上的資料會比訪問 Stack 上的資料慢，因為必須通過指標去訪問資料

現代處理器在記憶體中跳轉次數越少就越快 (Cache)

假設一個服務生在處理餐廳的點餐，最有效率的點餐方式就是一桌全部點完換下一桌，如果從 A 桌點完一道菜就換 B 桌點一道菜，B 桌點完又換回 A 桌點一道菜，這會導致效率很差

因此，處理器在處理彼此位址較接近的資料 (例如 Stack) 會比較快

處理彼此位址較遠的資料 (例如 Heap) 會比較慢，在 Heap 上分配大量的空間也有可能導致效率變差

### Rust 所有權要處理的問題

當你的程式碼調用函數時，傳遞給函數的值 (包括可能指向 Heap 上資料的指標) 和函數的局部變數會被加入 Stack 中，當函數結束時，這些值就會被移出 Stack

跟蹤哪部分程式碼正在使用 Heap 上的哪些資料，最大限度地減少 Heap 上重複資料的數量，以及清理 Heap 上不再被使用的資料，確保空間不會耗盡，這些問題正是 Rust 所有權所要處理的問題

## 所有權規則

Rust 所有權的規則

- Rust 中每一個值都有一個所有者 (owner)
- 一次只能有一個所有者
- 當所有者離開作用域，這個值將被丟棄

## 變數作用域

舉一個例子來看變數的作用域，假設我們有一個變數

```rust
let s = "hello";
```

這個變數從宣告的點開始直到當前作用域結束前都有效

```rust
{
    // s 在這裡無效，因為它尚未被宣告
    let s = "hello"; // 從這裡開始，s 是有效的

    // 到這裡 s 依然有效
} // 作用域結束，s 不再有效
```

這裡有兩個重要的時間點

- 當 `s` 被宣告進入作用域時，它是有效的
- `s` 的有效性會一直持續到離開作用域為止

## String 類型

字符串字面量 (string literal) 雖然很方便，但不適合使用文本的每一種場景，因為字符串字面量是不可變的，此外並不是所有字符串總是能在寫程式碼的時候提前得知，例如需要請用戶輸入的資料

```rust
let s = "hello" // 這個 hello 就是 string literal
```

想要獲取用戶輸入的資料並儲存，可以使用 Rust 的另外一種字符串類型 `String`，這個類型會將資料分配到 Heap 上，所以可以儲存未知大小的文本，我們可以使用 `from` 來接收我們給定的字符串並建立 `String`

```rust
let s = String::from("hello");
```

`::` 是運算符，允許將 `from` 函數放置於 `String` 類型的命名空間 (namespace) 下

注意 `String` 字符串是可以修改的

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() 在原本的字符串後面追加字符串

println!("{}", s); // 會印出 hello, world
```

## 記憶體與分配

字符串字面值在我們編譯時就能知道其內容，所以文本直接被硬編碼 (hardcoded) 至可執行文件中，這使得字符串字面值相當高效率，這得益於它的不可變性

對於 `String` 類型，為了支持一個可變的文本，需要在 Heap 上分配一塊用來存放未知大小的記憶體，這也表示

- 必須在執行時向作業系統請求記憶體
- 需要一個當我們處理完 `String` 時，將記憶體歸還給作業系統的方法

第一點在調用 `String::from` 時就已經實現 (implementation)

第二點根據各語言而有所不同，有垃圾回收機制的語言會幫我們處理，而沒有垃圾回收機制的語言，就需要開發者自行判讀不再使用的記憶體，並調用程式碼進行釋放

Rust 採取了一個不同於垃圾回收的策略，**一旦擁有該記憶體的變量離開作用域，記憶體將自動釋放**

```rust
{
    let s = String::from("hello"); // 從此處起，s 是有效的

    // 使用 s
} // 此作用域已结束，Rust 調用 drop 釋放記憶體
// s 不再有效
```

當 `s` 離開作用域，Rust 會自動幫我們調用一個特殊函數 `drop` 釋放記憶體
